---
outline: deep
---

# Лабораторна робота №5
---
## Мета роботи:
- Вивчити особливості циклічних обчислювальних процесів з розгалуженнями
- Опанувати технологію рекурентних обчислень
- Навчитися розробляти алгоритми та програми розвинення функцій у ряди

## Аналіз задачі

### Завдання 1
![image](https://github.com/knapulia/Knap/assets/144539321/54fd58c4-8316-482b-bb12-bcc8ca5d196b)

Обчислити значення рекурсивної функції, заданої рекурентним співвідношенням. Визначити глибину рекурсії. Здійснити аналіз ефективності рекурсивного розв'язку задачі. Варіанти завдання 1 подані в таблиці 5.1. Програма повинна реалізовувати два способи розв'язання лабораторного завдання: з використанням рекурсії та з використанням ітерації (циклу). В процесі ітераційної реалізації завдання слід підсумувати кількість ітерацій.

### Блок-схема 1


---
### Завдання 2
Увести з клавіатури два натуральних a і b. Визначити кількість послідовностей з a нулів і b одиниць, в яких ніякі два нулі не стоять поруч. Вивести знайдені послідовності з нулів та одиниць. Контрольний тест: введені числа 2 2, отриманий результат: 3 0101 1010 0110.

Рекурсивна обробка послідовностей. Забороняється використовувати масиви і рядки. Використання рекурсії для розв'язання завдання 2 обов'язково!!
Варіанти завдання 2 подані в таблиці 5.2
### Блок-схема 2

---
### Код програми 1
```cpp
#include<iostream>
#include<windows.h>

using namespace std;

int n;
// рекурсивна реалізація програми
int triangle_pascal(int i, int j)
{
	
	// ітеративна реалізація програми
	for (int i = 0; i < n; i++) {
		int k = 1;
		for (int j = 0; j <= i; j++) {
			cout << k << " ";
			k = k * (i - j) / (j + 1);
		}
		cout << endl;
	}
	return 0;
}

int main()
{
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);
	cout << "Лабараторна 5. ІПЗ-12 Кнап Юлія (Варіант 10)" << endl;
	cout << "---------------------------------------------------------" << endl;
	cout << "Трикутник Паскаля" << endl;
	cout << "Введіть кількість перших рядів трикутника Паскаля n:" << endl;
	cin >> n;

	// виведення трикутника Паскаля на екран
	
	for (int i = 0; i < n; i++) {
		int k = 1;
		for (int j = 0; j <= i; j++) {
			cout << k << " ";
			k = k * (i - j) / (j + 1);
		}
		cout << endl;
	}
	
	return 0;
}" 
```
---
### Код програми 1
```cpp
#include <iostream>
#include <vector>
using namespace std;

int count_0;
int count_1;
int a, b, result;

// Функція виводу числа у двійковому форматі на дісплей. N - число, temp - кількість розрядів
void binout(int N, int temp)
{
	if (temp == 0) return;
	if ((N & 1) == 0) {
		cout << "0" << " ";
	}
	else cout << "1" << " ";
	return (binout(N >> 1, temp - 1));
}
// Рекурсивна ф-ція підрахунку бітів 
// числа встановлених в "1"
int recursiveCount(int N)
{
	if (N == 0) {
		return 0;
	}
	return (N & 1) + recursiveCount(N >> 1); //зсуваємо число на один біт вправо і робимо логічне "І" над нульовим бітом і числом 01
}
// Функція логічного доповнення до одиниці (інвертуємо біти числа: 0 стає 1, 1 стає 0). Необхідно для підрахунку нулів в числі
int onesComplement(int N)
{
	// pow(2, N) - 1  
	return (((1 << (a + b)) - 1) ^ N);
}
// Ф - ція підрахунку кількості двох бітів
// числа встановлених в "0" в поспіль (00), 
// кількості бітів, встановлених в 0 і кількості 
// бітів встановлених в 1
void count00s1s0s(int N)
{
	int count00, count0, count1, M;

	M = onesComplement(N); // Інвертуємо число N
	count00 = recursiveCount(M & (M << 1)); // Для пошуку 00 робимо зсув на 1 біт вліво і робимо "І". Кількість "1" відповідає кількості 00
	if (count00 >= 1) return; // якщо є хоч одна комбінація 00, то переходимо до наступного числа

	count1 = recursiveCount(N); // Рахуємо кількість "1" в числі
	count0 = recursiveCount(M); // Рахуємо кількість "0" в числі (фактично кількість "1" в інвертованому числі)
	if (count0 < a || count1 < b) return; // якщо кількість 0 і 1 менше за введені a і b, то переходимо до наступного числа
	result++;
	binout(N, a + b);
	cout << endl;
	return;
}
// Функція рекурсивної перевірки всіх чисел 
void conditions(int N)
{
	if (N == 0) return;
	count00s1s0s(N);
	return(conditions(N - 1));
}
int main()
{                // захист від дурня
	cout << "Lab 5. Var 10, Knap Yulia, IPZ-12 " << endl;
	cout << "----------------------------------------------------" << endl;

	bool answer = 0; // Відповідь для повторення розрахунку
	int sposib = 1; // Спосіб введення масиву
	int N; int n;

	do {    //захист від дурня
		cout << "Enter a natural number - a (number of zeros):";
		cin >> a;
		if (a < 0)
			cout << "The number a is negative. Try again!" << endl;
	} while (a < 0);
	do { 
		cout << "Enter a natural number - b (number of ones):";
		cin >> b;
		if (b < 0)
			cout << "The number b is negative. Try again!" << endl;

	} while (b < 0);
	count_0 = 0; // скидаємо лічильник нулів в числі в нуль
	count_1 = 0; // скидаємо лічильник одиниць в числі в нуль
	result = 0; // кількість варіантів, які задовольняють умовам = 0
	N = pow(2, a + b) - 1; //максимальне число у двійковому форматі з кількістю розрядів = a+b
	conditions(N); // виклик функції перевірки умов задачі
	cout << "Number of sequence: " << result;
	
	return 0;
}" 
```
---
### Результат завдання 1
![image](https://github.com/knapulia/Knap/assets/144539321/aceffae7-d5cd-4507-a72c-f1cc4cc46b8a)

---
### Перевірка завдання 1
P(i,j)=C(i−1,j−1)

Отже, для 6 рядків трикутника Паскаля матимемо:

Рядок 0: 1
Рядок 1: 1 1
Рядок 2: 1 2 1
Рядок 3: 1 3 3 1
Рядок 4: 1 4 6 4 1
Рядок 5: 1 5 10 10 5 1

---
### Результат завдання 2
![image](https://github.com/knapulia/Knap/assets/144539321/75515d8d-1a4c-4c35-a007-1d64a64c35b7)

---
### Перевірка завдання 2
Поточний результат дорівнює контрольному тесту

---
### Висновок
На даній лабораторній роботі я вивчила особливості циклічних обчислювальних процесів з розгалуженнями,
опанувала технологію рекурентних обчислень та навчилася розробляти алгоритми та програми розвинення функцій у ряди.
Пограма написана успішно та результат її роботи перевірений на достовірність.

---
### Посилання на джерела
http://cpp.dp.ua/rekursyvni-funktsiyi/
https://www.bestprog.net/uk/2019/01/07/recursion-examples-of-tasks-solving-advantages-and-disadvantages-of-recursion-ua-2/
https://youtu.be/V7q9w_s0nns?si=kxEur5lnMV5jjZu0

---
